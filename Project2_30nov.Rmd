---
title: "Project2_30nov"
author: "Tushar Sharma"
date: "`r Sys.Date()`"
output: html_document
code_folding: hide 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = F, message = F)
```

```{r}
library(caret)
library(zoo)
library(ggplot2)
library(corrplot)
library(tidyverse)
library(gridExtra)
library(randomForest)
library(xgboost)
```

### Data

```{r}
bitcoin_data <- read.csv("C:\\Users\\tusha\\Downloads\\bitcoin_mining.csv")
```

### EDA 

```{r}
bitcoin_data_subset <- bitcoin_data[, !colnames(bitcoin_data) %in% c('Date.and.Time')]

# Compute the correlation matrix
cor_matrix <- cor(bitcoin_data_subset)

# Create a full correlogram
corrplot(
    cor_matrix,
    method = "circle",  # Use circle method for full mode
    type = "full",      # Display the full correlation matrix
    order = "hclust",   # Hierarchical clustering for ordering
    tl.col = "black",   # Label color
    tl.cex = 0.7        # Label size
)
```

### Time series cross validation folds of Price

```{r, fig.height = 10, fig.width = 8}
bitcoin_data$Date.and.Time <- as.Date(bitcoin_data$Date.and.Time)

# Sort data by 'Date.and.Time'
bitcoin_data <- bitcoin_data[order(bitcoin_data$Date.and.Time), ]

# Function to plot training and test sets
plot_train_test <- function(train_data, test_data, title) {
  ggplot() +
    geom_line(data = train_data, aes(x = Date.and.Time, y = Price), color = "blue", size = 1) +
    geom_line(data = test_data, aes(x = Date.and.Time, y = Price), color = "red", size = 1) +
    labs(title = title, x = "Date", y = "Price") +
    theme_minimal()
}

# Manual time series cross-validation
fold_size <- 363
training_size <- 3000
num_folds <- floor((nrow(bitcoin_data) - training_size) / fold_size) # better to have floor division

# Generate subplots for each fold
plots <- lapply(1 : num_folds, function(i) {
  start_idx <- (i - 1) * fold_size + 1
  end_idx <- start_idx + fold_size + training_size - 1

  train_data <- bitcoin_data[1 : (start_idx + training_size - 1), ]  # Update training set
  test_data <- bitcoin_data[(start_idx + training_size) : end_idx, ]

  title <- paste("Fold", i)
  plot_train_test(train_data, test_data, title) +
    xlim(range(bitcoin_data$Date.and.Time))  # Set x-axis limit for the entire date range
})

# Combine plots into a single facet_wrap
multiplot <- do.call(gridExtra::grid.arrange, c(plots, ncol = 1))
```

### Random forest regression


```{r, fig.height = 12, fig.width = 10}
plot_train_test <- function(train_data, test_data, title) {
  ggplot() +
    geom_line(data = train_data, aes(x = Date.and.Time, y = Price), color = "blue", size = 1) +
    geom_line(data = test_data, aes(x = Date.and.Time, y = Price), color = "red", size = 1) +
    labs(title = title, x = "Date", y = "Price") +
    theme_minimal()
}

# Function to calculate MAPE and MSPE
calculate_errors <- function(actual, predicted) {
  errors <- data.frame(
    MAPE = mean(abs((actual - predicted) / actual)) * 100,
    MSPE = mean(((actual - predicted) / actual)^2) * 100
  )
  return(errors)
}

# Function to perform random forest regression and calculate errors
perform_rf <- function(train_data, test_data) {
  # Input features
  train_feat <- c("Volume", "Hash.rate.MH.s", "power.MAX..GW")
  
  # Train random forest model
  rf_model <- randomForest(Price ~ ., data = train_data[, c(train_feat, "Price")])
  
  # Predict on test data
  test_data$predicted <- predict(rf_model, newdata = test_data)
  
  # Calculate MAPE and MSPE
  errors <- calculate_errors(test_data$Price, test_data$predicted)
  
  return(list(
    predictions = data.frame(
      Date.and.Time = test_data$Date.and.Time,
      Actual = test_data$Price,
      Predicted = test_data$predicted
    ),
    errors = errors
  ))
}

# List to store actual vs predicted results and errors for each fold
rf_results_list <- list()

# Manual time series cross-validation
for (i in 1 : num_folds) {
  start_idx <- (i - 1) * fold_size + 1
  end_idx <- start_idx + fold_size + training_size - 1
  
  # Split data into training and testing sets
  train_data <- bitcoin_data[1:(start_idx + training_size - 1), ]
  test_data <- bitcoin_data[(start_idx + training_size):end_idx, ]
  
  # Perform random forest regression
  results <- perform_rf(train_data, test_data)
  
  # Store results in the list
  rf_results_list[[paste("Fold", i)]] <- results
}

# Calculate averages of MAPE and MSPE across all folds
average_errors <- calculate_errors(
  actual = do.call(rbind, lapply(rf_results_list, function(x) x$predictions$Actual)),
  predicted = do.call(rbind, lapply(rf_results_list, function(x) x$predictions$Predicted))
)

# Visualize actual vs predicted results for each fold
rf_plots <- lapply(seq_along(rf_results_list), function(i) {
  results <- rf_results_list[[i]]
  title <- paste("Fold", i)
  
  ggplot(results$predictions, aes(x = Date.and.Time)) +
    geom_line(aes(y = Actual, color = "Actual"), size = 1) +
    geom_line(aes(y = Predicted, color = "Predicted"), size = 1, linetype = "solid") +
    labs(
      title = paste(title, " - MAPE:", round(results$errors$MAPE, 4), " MSPE:", round(results$errors$MSPE, 4)),
      x = "Date", y = "Price"
    ) +
    theme_minimal()
})

# Combine plots into a single facet_wrap
rf_multiplot <- do.call(gridExtra::grid.arrange, c(rf_plots, ncol = 1))
```

### XG Boost 


```{r, fig.height = 12, fig.width = 10}
# Function to plot training and test sets
plot_train_test <- function(train_data, test_data, title) {
  ggplot() +
    geom_line(data = train_data, aes(x = Date.and.Time, y = Price), color = "blue", size = 1) +
    geom_line(data = test_data, aes(x = Date.and.Time, y = Price), color = "red", size = 1) +
    labs(title = title, x = "Date", y = "Price") +
    theme_minimal()
}

# Function to calculate MAPE and MSPE
calculate_errors <- function(actual, predicted) {
  errors <- data.frame(
    MAPE = mean(abs((actual - predicted) / actual)) * 100,
    MSPE = mean(((actual - predicted) / actual)^2) * 100
  )
  return(errors)
}

# Function to train XGBoost model and make predictions
train_and_predict_xgb <- function(train_data, test_data) {
  # Specify XGBoost parameters
  params <- list(
    objective = "reg:squarederror"
  )
  
  # Train the XGBoost model
  train_feat <- c('Volume', 'Hash.rate.MH.s', 'power.MAX..GW')
  
  xgb_model <- xgboost(
    data = as.matrix(train_data[, train_feat]),  # Exclude Date.and.Time
    label = train_data$Price,
    params = params,
    nrounds = 500,
    print_every_n = 50  # Printing every 50 iterations
  )
  
  # Make predictions on the test set
  predictions <- predict(xgb_model, as.matrix(test_data[, train_feat]))
  
  # Calculate MAPE and MSPE
  errors <- calculate_errors(test_data$Price, predictions)
  
  # Store results without printing
  results <- data.frame(
    Date.and.Time = test_data$Date.and.Time,
    Actual = test_data$Price,
    Predicted = predictions,
    MAPE = errors$MAPE,
    MSPE = errors$MSPE
  )
  
  return(results)
}

# List to store actual vs predicted results and errors for each fold
results_list <- list()

# Manual time series cross-validation
for (i in 1:num_folds) {
  start_idx <- (i - 1) * fold_size + 1
  end_idx <- start_idx + fold_size + training_size - 1
  
  # Split data into training and testing sets
  train_data <- bitcoin_data[1:(start_idx + training_size - 1), ]
  test_data <- bitcoin_data[(start_idx + training_size):end_idx, ]
  
  # Train XGBoost model and make predictions
  results <- train_and_predict_xgb(train_data, test_data)
  
  # Store results in the list
  results_list[[paste("Fold", i)]] <- results
}

# Calculate averages of MAPE and MSPE across all folds
average_errors <- calculate_errors(
  actual = do.call(rbind, lapply(results_list, function(x) x$Actual)),
  predicted = do.call(rbind, lapply(results_list, function(x) x$Predicted))
)

# Visualize actual vs predicted results for each fold
plots <- lapply(seq_along(results_list), function(i) {
  results <- results_list[[i]]
  title <- paste("Fold", i)
  
  ggplot(results, aes(x = Date.and.Time)) +
    geom_line(aes(y = Actual, color = "Actual"), size = 1) +
    geom_line(aes(y = Predicted, color = "Predicted"), size = 1, linetype = "solid") +
    labs(
      title = paste(title, " - MAPE:", round(results$MAPE, 2), " MSPE:", round(results$MSPE, 2)),
      x = "Date", y = "Price"
    ) +
    theme_minimal()
})

# Combine plots into a single facet_wrap
multiplot <- do.call(gridExtra::grid.arrange, c(plots, ncol = 1))
```






