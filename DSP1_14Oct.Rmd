---
title: "DSP1"
output: html_document
date: "2023-10-05"
---

```{r setup, include=FALSE, out.width = "100%", out.height = "100%"}
knitr::opts_chunk$set(echo = FALSE)

options(repos = c(CRAN = "https://cloud.r-project.org/"))
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## loading the Dataset
### Just removed last 2 coloums as they doesnt contain any values and printed first 5 rows

```{r}
# Load the CSV data
bitcoin_mining <- read.csv("C:\\Users\\tusha\\Downloads\\bitcoin_mining.csv")

# Create a DataFrame from the loaded data
bitcoin_mining <- data.frame(bitcoin_mining)
print(colnames(bitcoin_mining))

# Select specific columns and removed 
data <- subset(
  bitcoin_mining, select = c(
  "Date.and.Time", "power.GUESS..GW", "annualised.consumption.GUESS..TWh",   "Estimated.efficiency..J.Th", "Hydro.only..MtCO2e", "Estimated..MtCO2e",  "Coal.only..MtCO2e", "Emission.intensity..gCO2e.kWh", "Hash.rate.MH.s"
  )
)

# View the selected columns
head(data)
```

## Imports

```{r}
install.packages("corrplot")
install.packages("GGally")

library(devtools)
library(ggplot2)
library(gridExtra)
library(scales)
library(dplyr)
library(zoo)
library(corrplot)
library(GGally)

```


## Checking the Structure of data

```{r}
str(data)

```
## Summary statistics

```{r}

summary(data)
```

## Subplots of all the 8 vairables 

#### Uncomment the line with ggsave() function to export a jpg picture of the subplots generated. Note that the layout of the plots displayed in .html knitted file and the exported image can be different!

```{r}
time_series_list <- list()

bitcoin_mining$Date.and.Time <- as.Date(bitcoin_mining$Date.and.Time)

columns_to_plot <- c("power.GUESS..GW", "annualised.consumption.GUESS..TWh", "Estimated.efficiency..J.Th", "Hydro.only..MtCO2e", "Estimated..MtCO2e", "Coal.only..MtCO2e", "Emission.intensity..gCO2e.kWh", "Hash.rate.MH.s")

cols <- c("Power guess (GW)", "Annualised consumption guess (TWh)", "Estimated efficiency J/Th", "Hydro-only MtCO2eq", "Estimated MtCO2eq", "Coal-only MtCO2eq", "Emission intensity gCO2eq/kWh", "Hash rate (MH/s)")

plot_width <- 14
plot_height <- 7

for (i in 1:length(columns_to_plot)) {
  col <- columns_to_plot[i]
  col_name <- cols[i]

  # Calculate appropriate date breaks based on data
  breaks <- ifelse(max(bitcoin_mining$Date.and.Time, na.rm = TRUE) - min(bitcoin_mining$Date.and.Time, na.rm = TRUE) > 2 * 365,
                   date_breaks("2 year"), date_breaks("1 year"))

  p <- ggplot(bitcoin_mining, aes(x = Date.and.Time, y = .data[[col]])) +
    geom_line(color = "blue", alpha = 0.8) +
    labs(x = if (i > 4) "Date" else "", y = col_name) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
          axis.text.y = element_text(size = 10),
          axis.title.x = element_text(size = 10),
          axis.title.y = element_text(size = 10)) +
    scale_x_date(breaks = breaks, date_labels = "%Y", expand = c(0, 0))

  time_series_list[[col]] <- p
}

grid.arrange(grobs = time_series_list, ncol = 4, width = plot_width * 4, height = plot_height * 2)
```
## 
## Boxplots  

```{r}
boxplot_list <- list()

for (i in 1:length(columns_to_plot)) {
    col <- columns_to_plot[i]
    col_name <- cols[i]
    
   p <- ggplot(data, aes(x = factor(1), y = .data[[col]])) +
        geom_boxplot(fill = "lightblue", color = "black", width = 0.5) +
        geom_segment(aes(y = median(.data[[col]]), yend = median(.data[[col]]),
                         x = 0.75, xend = 1.25), size = 0.7, color = 'red') +
        geom_segment(aes(y = min(.data[[col]]), yend = min(.data[[col]]),
                          x = 0.7, xend = 1.3), size = 0.7, color = 'black') +
         geom_segment(aes(y = max(.data[[col]]), yend = max(.data[[col]]),
                          x = 0.7, xend = 1.3), size = 0.7, color = 'black') +
        labs(x = "", y = col_name) +
        scale_fill_manual(values = c("lightblue")) + 
        theme_minimal() +
        theme(axis.text.x = element_blank(),
              axis.text.y = element_text(size = 8.5),
              axis.title.x = element_blank(),
              axis.title.y = element_text(size = 8.5, margin=margin(0,6,0,0)),
              plot.margin = margin(0,15,0,0)) +
        ylim(0, max(data[[col]], na.rm = TRUE) * 1.2)  
    
    boxplot_list[[col]] <- p
}
grid.arrange(grobs = boxplot_list, ncol = 4, width = 14, height = 10)
```

## Correlation plots

```{r}
rename <- c("Power guess", "Ann. consumption guess", "Est. efficiency", "Hydro-only MtCO2eq", "Estimated MtCO2eq",  "Coal-only MtCO2eq", "Emission intensity", "Hash rate")

selected_data <- bitcoin_mining[columns_to_plot]
selected_data <- na.omit(selected_data)
selected_data <- sapply(selected_data, as.numeric)
selected_data <- as.data.frame(selected_data)

scatter_plot_list <- list()
unique_pairs <- combn(ncol(selected_data), 2)
num_pairs <- ncol(unique_pairs)

for (i in 1 : num_pairs) {
    x_var <- unique_pairs[1, i]
    y_var <- unique_pairs[2, i]
    
    scatter_plot <- ggally_points(
        data = selected_data,  
        mapping = aes_string(
            x = colnames(selected_data)[x_var],
            y = colnames(selected_data)[y_var]),
        color = "blue", size = 1, pch = 21) +
        geom_point(color = "blue", size = 1) +
        labs(x = rename[x_var], y = rename[y_var]) +
        
        theme(axis.text.x = element_text(size = 10), 
              axis.text.y = element_text(size = 10),
              axis.title.x = element_text(size = 10), 
              axis.title.y = element_text(size = 10))
    
    scatter_plot_list[[i]] <- scatter_plot
}

grid.arrange(grobs = scatter_plot_list, ncol = 4, width = 6 * 4, heights = rep(3, ceiling(num_pairs / 4)))
```

## Correlation matrix

```{r}
correlation_matrix <- cor(selected_data, use = "complete.obs")

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF",
                          "#77AADD", "#4477AA"))

names <- c("Power guess", "Annualised consumption guess", "Estimated.efficiency", "Hydro-only MtCO2eq", "Estimated MtCO2eq", "Coal-only MtCO2eq", "Emission intensity", "Hash rate")

colnames(correlation_matrix) <- names
rownames(correlation_matrix) <- names

corrplot(correlation_matrix,  # Replace with your correlation matrix
          method = "color",  # Use color to represent correlations
          col = col(200),  # Color palette
          type = "full",  # Display the upper triangle of the matrix
          order = "hclust",  # Order variables using hierarchical clustering
          addCoef.col = "black",  # Color of correlation coefficient labels
          tl.col = "black",  # Text label color
          tl.srt = 45,  # Text label rotation angle
          tl.cex = 0.8,
          sig.level = 0.01,  # Significance level
          insig = "blank",  # Display "blank" for insignificant correlations
          # Hide correlation coefficient on the principal diagonal
          diag = TRUE
)
```

## Stationarity analysis of time series
  
```{r}
start_date <- as.Date("2010-07-18")
end_date <- as.Date("2023-09-22")

data_frame <- data.frame(Date = seq.Date(start_date, end_date, by = "weeks"))

interval_weeks <- 104  # 2 years (approx 104 weeks)
plot_list <- list()

rename <- c("Power guess", "Ann. consumption guess", "Est. efficiency", "Hydro-only MtCO2eq", "Estimated MtCO2eq", "Coal-only MtCO2eq", "Emission intensity", "Hash rate")

for (col_name in columns_to_plot) {
  ts_data <- ts(bitcoin_mining[[col_name]], frequency = 365)

  rolling_data <- data.frame(Date = as.Date(character(0)), RollingMean = numeric(0), RollingSD = numeric(0))

  for (i in seq(start_date, end_date, by = paste(interval_weeks / 52, "years"))) {
    interval_start <- i
    interval_end <- i + 2 * 365  # 2 years in days

    subset_data <- data_frame %>%
      filter(Date >= interval_start, Date < interval_end)

    mean_value <- mean(ts_data[subset_data$Date - start_date + 1])
    sd_value <- sd(ts_data[subset_data$Date - start_date + 1])

    rolling_data <- rbind(rolling_data, data.frame(Date = interval_start + 365, RollingMean = mean_value, RollingSD = sd_value))
  }

  rolling_data$Date <- as.Date(rolling_data$Date)

  plot_data <- rolling_data %>%
    filter(!is.na(RollingMean) & !is.na(RollingSD))

  plot <- ggplot(plot_data, aes(x = Date)) +
    geom_point(aes(y = RollingMean), color = "blue", size = 2) +
    geom_line(aes(y = RollingMean), color = "blue", size = 1) +
    geom_point(aes(y = RollingSD), color = "red", size = 2) +
    geom_line(aes(y = RollingSD), color = "red", size = 1) +
    labs(x = "Date", y = paste("Rolling Mean/SD of", rename[which(columns_to_plot == col_name)])) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 7),  
          axis.text.y = element_text(size = 7),  
          axis.title.x = element_text(size = 7),  
          axis.title.y = element_text(size = 7)) +
    scale_x_date(date_labels = "%Y", date_breaks = "2 years")

  plot_list[[col_name]] <- plot
}

grid.arrange(grobs = plot_list, ncol = 4, width = 14 * 4, height = 7 * ceiling(length(columns_to_plot) / 4))
```



